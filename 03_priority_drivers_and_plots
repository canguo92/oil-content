#!/usr/bin/env Rscript
# ------------------------------------------------------------------------------
# 03_priority_drivers_and_plots.R
# 从“第一象限（Observed & Climate-driven）”县反推致降的“确切气候驱动因子”，
# 并生成 Top-N 横排条形图、家族占比堆叠图、强度热图（log1p 统一色标）。
#
# Usage（示例）：
#   Rscript scripts/03_priority_drivers_and_plots.R \
#     --cross_csv outputs_cross/CROSS_county.csv \
#     --b4_csv outputs_tuned/B4_year_county_feature_SHAP.csv \
#     --outdir outputs_cross \
#     --topk_per_county 5 \
#     --topk_per_year 10 \
#     --topm_heatmap 12 \
#     --years "2012,2016,2019,2021,2023"
#
# 注意：
# - cross_csv 需包含（至少其一）：
#     1) quadrant_pro（四象限标签）或
#     2) A_flag_top / B_flag_top（将据此构造 quadrant_pro）
#   且含 grow_year, Province, City, County。
# - b4_csv 为 B4（year-county-feature SHAP 长表或宽表），含 grow_year, Province, City, County，
#   以及 feature 与 shap（或可从宽表数值列 pivot 成长表）。
# - 输出：<outdir>/drivers/* 与 <outdir>/drivers/plots/*
# ------------------------------------------------------------------------------

suppressPackageStartupMessages({
  pkgs <- c("readr","dplyr","tidyr","stringr","purrr","openxlsx","ggplot2","cowplot","optparse")
  to_install <- pkgs[!pkgs %in% installed.packages()[,1]]
  if (length(to_install)) install.packages(to_install, repos = "https://cloud.r-project.org")
  library(readr); library(dplyr); library(tidyr); library(stringr); library(purrr)
  library(openxlsx); library(ggplot2); library(cowplot); library(optparse)
})

# ----------------------- CLI -----------------------
option_list <- list(
  make_option("--cross_csv",       type="character", help="Path to CROSS_county.csv"),
  make_option("--b4_csv",          type="character", help="Path to B4_year_county_feature_SHAP.csv"),
  make_option("--outdir",          type="character", default="outputs_cross", help="Output root dir (default: outputs_cross)"),
  make_option("--topk_per_county", type="integer",   default=5,  help="Top-K drivers per county (default: 5)"),
  make_option("--topk_per_year",   type="integer",   default=10, help="Top-K drivers per year for bar plots (default: 10)"),
  make_option("--topm_heatmap",    type="integer",   default=12, help="Top-M drivers per year included in heatmap (default: 12)"),
  make_option("--years",           type="character", default="2012,2016,2019,2021,2023",
              help='Comma-separated years or "all" (default: "2012,2016,2019,2021,2023")')
)
args <- parse_args(OptionParser(option_list = option_list))
stopifnot(!is.null(args$cross_csv), file.exists(args$cross_csv))
stopifnot(!is.null(args$b4_csv),    file.exists(args$b4_csv))

OUT_DIR   <- normalizePath(args$outdir, winslash = "/", mustWork = FALSE)
DRV_DIR   <- file.path(OUT_DIR, "drivers"); dir.create(DRV_DIR, showWarnings = FALSE, recursive = TRUE)
PLOT_DIR  <- file.path(DRV_DIR, "plots");  dir.create(PLOT_DIR, showWarnings = FALSE, recursive = TRUE)

TOPK_PER_COUNTY <- as.integer(args$topk_per_county)
TOPK_PER_YEAR   <- as.integer(args$topk_per_year)
TOPM_HEATMAP    <- as.integer(args$topm_heatmap)
YEARS_FORCE     <- if (tolower(args$years) == "all") integer(0) else as.integer(strsplit(args$years, ",")[[1]])

# ----------------------- Utils -----------------------
robust_read_csv <- function(path){
  for (enc in c("GB18030","UTF-8","UTF-8-BOM","GBK","latin1")){
    x <- try(readr::read_csv(path, locale=readr::locale(encoding=enc),
                             show_col_types = FALSE), silent = TRUE)
    if (!inherits(x, "try-error")) return(x)
  }
  stop("读取失败: ", path)
}

# 象限标签
lab_priority <- "Observed & Climate-driven"
lab_obs_only <- "Observed-only"
lab_clim_only<- "Climate-driven-only"
lab_non     <- "Non-hotspot"

# 去掉 “All Stage(s)” 和括号内容
scrub_all_stage <- function(x){
  x <- as.character(x)
  x <- gsub("\\s*\\(\\s*All\\s*Stage[s]?\\s*\\)", "", x, ignore.case=TRUE, perl=TRUE)
  x <- ifelse(grepl("^\\s*(all\\s*stage[s]?|overall|whole\\s*(season|growth|period)|entire\\s*season|all\\s*period|whole\\s*period|whole\\s*growth)\\s*$",
                    x, ignore.case=TRUE, perl=TRUE), "", x)
  x <- gsub("\\(\\s*\\)", "", x)
  x <- gsub("\\s+", " ", trimws(x))
  x[x==""] <- NA_character_
  x
}
scrub_driver_key <- function(x){
  x <- as.character(x)
  x <- gsub("\\(?\\s*all\\s*stage[s]?\\s*\\)?", "", x, ignore.case = TRUE, perl = TRUE)
  x <- gsub("\\s*\\([^)]*\\)\\s*", " ", x, perl = TRUE)
  x <- trimws(gsub("\\s+", " ", x))
  x[x==""] <- NA_character_
  x
}

# 将 B4 标准化为长表（优先识别 feature/shap 长表；否则从宽表 pivot）
normalize_b4_to_long <- function(df, verbose = TRUE){
  names(df) <- trimws(names(df))
  key_cols_all <- c("grow_year","Province","City","County","Region")
  key_cols <- intersect(key_cols_all, names(df))
  feat_col <- c("feature","variable","Feature","var","predictor"); feat_col <- feat_col[feat_col %in% names(df)][1]
  shap_col <- c("shap","shap_value","phi","value","neg","neg_sum","neg_sum_county","shap_neg"); shap_col <- shap_col[shap_col %in% names(df)][1]
  phase_col<- c("phase","phenophase","period","stage"); phase_col<- phase_col[phase_col %in% names(df)][1]
  if (!is.na(feat_col) && !is.na(shap_col)) {
    if (verbose) message("B4 识别为：长表（已有 feature/shap）。")
    sel_cols <- unique(c(key_cols, feat_col, shap_col, if (!is.na(phase_col)) phase_col))
    out <- df[, sel_cols, drop = FALSE]
    if (feat_col %in% names(out)) names(out)[names(out)==feat_col] <- "feature"
    if (shap_col %in% names(out)) names(out)[names(out)==shap_col] <- "shap"
    if (!is.na(phase_col) && phase_col %in% names(out)) names(out)[names(out)==phase_col] <- "phase"
  } else {
    if (verbose) message("B4 识别为：宽表（按数值列 pivot_longer）。")
    num_cols <- names(df)[sapply(df, is.numeric)]
    cand_feat_cols <- setdiff(num_cols, c("grow_year"))
    if (length(cand_feat_cols) == 0) {
      not_key <- setdiff(names(df), key_cols)
      cand_feat_cols <- not_key[sapply(df[not_key], function(x) is.numeric(x) || is.integer(x))]
    }
    if (length(cand_feat_cols) == 0) stop("无法识别 B4 的特征列。")
    out <- df %>%
      tidyr::pivot_longer(cols = dplyr::all_of(cand_feat_cols),
                          names_to = "feature", values_to = "shap") %>%
      dplyr::select(dplyr::all_of(intersect(c("grow_year","Province","City","County"), names(.))),
                    feature, shap)
  }
  out$feature <- scrub_all_stage(out$feature)
  out$shap    <- suppressWarnings(as.numeric(out$shap))
  if (!"phase" %in% names(out)) out$phase <- NA_character_
  out$phase   <- scrub_all_stage(out$phase)
  out
}

# 变量名 → 可读驱动标签（不拼括号）
pretty_driver <- function(feat, phase = NA){
  f <- tolower(as.character(feat))
  dplyr::case_when(
    stringr::str_detect(f, "rain|precip|prcp|rainfall|wet")         ~ "Extreme rainfall",
    stringr::str_detect(f, "heat|high.*temp|hightemp|tmax|hot")     ~ "Heat days",
    stringr::str_detect(f, "frost|cold|tmin|chilling|freeze")       ~ "Cold days",
    stringr::str_detect(f, "temp|temperature")                      ~ "Temperature",
    stringr::str_detect(f, "vpd")                                   ~ "VPD",
    stringr::str_detect(f, "solar|rad|srad|rsds|shortwave")         ~ "Solar radiation",
    stringr::str_detect(f, "humidity|rh")                           ~ "Humidity",
    stringr::str_detect(f, "wind")                                  ~ "Wind",
    stringr::str_detect(f, "drought|spei|spi")                      ~ "Drought index",
    TRUE ~ stringr::str_to_title(gsub("_", " ", as.character(feat)))
  )
}
make_driver_key <- function(feature, phase = NA) pretty_driver(feature, phase)

# 四大类分组 + 调色板
grp_levels <- c("Thermal (heat)", "Cold stress", "Moisture", "Radiation")
grp_pal <- c(
  "Thermal (heat)" = "#E41A1C",
  "Cold stress"    = "#377EB8",
  "Moisture"       = "#4DAF4A",
  "Radiation"      = "#984EA3"
)
assign_feature_group_no_others <- function(features){
  s <- tolower(as.character(features))
  grp <- rep(NA_character_, length(s))
  cold_pat <- paste(
    "cold|frost|chill|freeze|freezing|\\blow\\s*temp\\b|cold\\s*spell",
    "|(^|[_-])tnn($|[_-])|(^|[_-])fdd($|[_-])|(^|[_-])fd($|[_-])|(^|[_-])iid($|[_-])",
    sep = ""
  )
  heat_pat <- paste(
    "heat|hot|warm|\\btemp\\b|tmean|tmax|maxt|meant|mint|degree\\s*day|growing\\.?degree|\\bgdd\\b|\\bedd\\b|(^|[_-])txx($|[_-])|etr|\\bgsl\\b|\\bdtr\\b|(^|[_-])ihd($|[_-])",
    sep = ""
  )
  moist_pat <- paste(
    "rain|rainfall|precip|\\brx1day\\b|\\brx5day\\b|\\br10\\b|\\br20\\b|\\br95\\b|sdii",
    "|\\bcdd\\b|\\bcwd\\b|spei|\\bspi\\b|pdsi|smdi|drought|\\bwet\\b|\\bdry\\b",
    "|\\bevap\\b|evapo|\\bet0\\b|\\bpet\\b|\\baet\\b|\\beta\\b",
    "|\\bvpd\\b|humidity|\\brh\\b|relative\\s*humidity|vapor\\s*press|\\bvp\\b",
    "|soil.*moist|\\bsm(\\b|_)|swc|theta|snow",
    sep = ""
  )
  rad_pat <- "srad|(^|[_-])rad($|[_-])|shortwave|\\brsds\\b|par|solar|sunshine|\\bsun\\b|insol|cloud"
  grp[grepl(cold_pat,  s, perl=TRUE)] <- "Cold stress"
  grp[is.na(grp) & grepl(heat_pat,  s, perl=TRUE)] <- "Thermal (heat)"
  grp[is.na(grp) & grepl(moist_pat, s, perl=TRUE)] <- "Moisture"
  grp[is.na(grp) & grepl(rad_pat,   s, perl=TRUE)] <- "Radiation"
  grp[is.na(grp) | grp==""] <- "Thermal (heat)"  # 兜底，避免 NA/Others
  factor(grp, levels = grp_levels)
}

# 统一主题（无特定字体依赖）
nature_light <- function(base_size = 11){
  theme_classic(base_size = base_size) %+replace%
    theme(axis.ticks = element_line(linewidth = 0.3),
          axis.line  = element_line(linewidth = 0.5),
          panel.grid = element_blank(),
          legend.position = "right")
}
theme_set(nature_light(11))

# ----------------------- A) 读取与筛选 -----------------------
CROSS_cnt <- robust_read_csv(args$cross_csv); names(CROSS_cnt) <- trimws(names(CROSS_cnt))
if (!"quadrant_pro" %in% names(CROSS_cnt)) {
  if (!all(c("A_flag_top","B_flag_top") %in% names(CROSS_cnt))) {
    stop("CROSS_county.csv 缺少 quadrant_pro 或 A_flag_top/B_flag_top。")
  }
  CROSS_cnt <- CROSS_cnt %>%
    mutate(
      obs_flag_top  = if_else(A_flag_top == 1L, 1L, 0L),
      clim_flag_top = if_else(B_flag_top == 1L, 1L, 0L),
      quadrant_pro  = case_when(
        obs_flag_top==1L & clim_flag_top==1L ~ lab_priority,
        obs_flag_top==1L & clim_flag_top==0L ~ lab_obs_only,
        obs_flag_top==0L & clim_flag_top==1L ~ lab_clim_only,
        TRUE                                 ~ lab_non
      )
    )
}
if (length(YEARS_FORCE) > 0) {
  CROSS_cnt <- CROSS_cnt %>% filter(grow_year %in% YEARS_FORCE)
}
pri_cnty <- CROSS_cnt %>%
  filter(quadrant_pro == lab_priority) %>%
  select(grow_year, Province, City, County) %>%
  distinct()

B4_raw  <- robust_read_csv(args$b4_csv)
B4_long <- normalize_b4_to_long(B4_raw)
stopifnot(all(c("grow_year","Province","City","County","feature","shap") %in% names(B4_long)))

B4_use <- B4_long %>%
  semi_join(pri_cnty, by = c("grow_year","Province","City","County")) %>%
  filter(is.finite(shap))

# 仅取负向 SHAP（致降）
if (mean(B4_use$shap < 0, na.rm = TRUE) < 0.5) {
  message("检测到 shap 多为正：将过滤 shap < 0 作为“致降驱动”。")
}
B4_neg <- B4_use %>% filter(shap < 0)
if (!"phase" %in% names(B4_neg)) B4_neg$phase <- NA_character_

# 生成 driver_key
B4_neg <- B4_neg %>%
  mutate(
    feature    = scrub_all_stage(feature),
    phase      = scrub_all_stage(phase),
    driver_key = make_driver_key(feature, phase),
    driver_key = scrub_driver_key(driver_key),
    mass       = abs(shap)
  )

# ----------------------- A-1) 每县 Top-K 驱动 -----------------------
drivers_by_cnty <- B4_neg %>%
  group_by(grow_year, Province, City, County, driver_key) %>%
  summarise(mass = sum(mass, na.rm = TRUE), .groups = "drop") %>%
  group_by(grow_year, Province, City, County) %>%
  slice_max(order_by = mass, n = TOPK_PER_COUNTY, with_ties = FALSE) %>%
  ungroup()

drivers_by_cnty$driver_key <- scrub_driver_key(drivers_by_cnty$driver_key)
readr::write_csv(drivers_by_cnty, file.path(DRV_DIR, "priority_counties_top_drivers.csv"))

# ----------------------- A-2) 每年聚合 Top 驱动 -----------------------
drivers_year_agg <- B4_neg %>%
  group_by(grow_year, driver_key) %>%
  summarise(
    mass_total = sum(mass, na.rm = TRUE),
    n_counties = n_distinct(paste(Province, City, County, sep="|")),
    .groups = "drop"
  ) %>%
  arrange(grow_year, desc(mass_total)) %>%
  group_by(grow_year) %>%
  mutate(rank_by_mass = row_number()) %>%
  ungroup()

drivers_year_agg$driver_key <- scrub_driver_key(drivers_year_agg$driver_key)
readr::write_csv(drivers_year_agg, file.path(DRV_DIR, "year_aggregated_drivers.csv"))

# Excel 汇总
wb <- openxlsx::createWorkbook()
openxlsx::addWorksheet(wb, "ByCounty_TopK");     openxlsx::writeData(wb, "ByCounty_TopK", drivers_by_cnty)
openxlsx::addWorksheet(wb, "ByYear_Aggregated");  openxlsx::writeData(wb, "ByYear_Aggregated", drivers_year_agg)
openxlsx::saveWorkbook(wb, file.path(DRV_DIR, "priority_drivers_outputs.xlsx"), overwrite = TRUE)

# ----------------------- B) 可视化 -----------------------
# 补家族
drivers_by_cnty  <- drivers_by_cnty  %>% mutate(driver_key = scrub_driver_key(driver_key),
                                                family = assign_feature_group_no_others(driver_key))
drivers_year_agg <- drivers_year_agg %>% mutate(driver_key = scrub_driver_key(driver_key),
                                                family = assign_feature_group_no_others(driver_key))

# 年份筛选
if (length(YEARS_FORCE) > 0) {
  drivers_by_cnty  <- drivers_by_cnty  %>% filter(grow_year %in% YEARS_FORCE)
  drivers_year_agg <- drivers_year_agg %>% filter(grow_year %in% YEARS_FORCE)
}
years_plot <- sort(unique(drivers_year_agg$grow_year))

# 图1：每年 Top-N 横排条形图（合并一行，右侧统一图例）
make_topN_plot_one_year <- function(yr, topN = TOPK_PER_YEAR){
  dd <- drivers_year_agg %>%
    filter(grow_year == yr) %>%
    arrange(desc(mass_total)) %>%
    slice_head(n = topN)
  if (nrow(dd) == 0) return(NULL)
  ggplot(dd, aes(x = reorder(driver_key, mass_total), y = mass_total, fill = family)) +
    geom_col(width = 0.75) +
    coord_flip() +
    scale_fill_manual(values = grp_pal, limits = grp_levels, drop = FALSE) +
    labs(x = NULL, y = "Total negative SHAP (abs)") +
    theme(legend.position = "none")
}
top_list <- lapply(years_plot, function(yr) make_topN_plot_one_year(yr, TOPK_PER_YEAR))
blank_panel <- ggplot() + theme_void()
top_list <- lapply(top_list, function(p) if (is.null(p)) blank_panel else p)

legend_dummy <- data.frame(
  driver_key = factor(rep("dummy", length(grp_levels))),
  mass_total = 1,
  family     = factor(grp_levels, levels = grp_levels)
)
legend_src <- ggplot(legend_dummy, aes(driver_key, mass_total, fill = family)) +
  geom_col() +
  scale_fill_manual(values = grp_pal, limits = grp_levels, drop = FALSE) +
  theme(legend.position = "right")
legend_grob <- cowplot::get_legend(legend_src)

letters_lab <- letters[seq_along(top_list)]
top_row <- cowplot::plot_grid(plotlist = top_list, nrow = 1, labels = letters_lab,
                              label_fontface = "bold", label_size = 12, align = "h")
top_row_with_leg <- cowplot::plot_grid(top_row, legend_grob, ncol = 2, rel_widths = c(1, 0.12))
ggsave(file.path(PLOT_DIR, "DRV_AllYears_TopDrivers_row.tiff"),
       top_row_with_leg, width = 16, height = 4.5, dpi = 600, compression = "lzw")
ggsave(file.path(PLOT_DIR, "DRV_AllYears_TopDrivers_row.png"),
       top_row_with_leg, width = 16, height = 4.5, dpi = 300)

# 图2：四大类在各年的贡献占比（堆叠柱）
drivers_year_agg <- drivers_year_agg %>%
  group_by(grow_year) %>%
  mutate(mass_year_total = sum(mass_total, na.rm = TRUE),
         share = ifelse(mass_year_total > 0, mass_total / mass_year_total, 0)) %>%
  ungroup()

stack_year <- drivers_year_agg %>%
  group_by(grow_year, family) %>%
  summarise(share = sum(share, na.rm = TRUE), .groups = "drop") %>%
  mutate(family = factor(family, levels = grp_levels))

p_stack <- ggplot(stack_year, aes(x = factor(grow_year), y = share, fill = family)) +
  geom_col(width = 0.7) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1),
                     expand = ggplot2::expansion(mult = c(0.02, 0.05))) +
  scale_fill_manual(values = grp_pal, limits = grp_levels, drop = FALSE) +
  labs(x = "Year", y = "Share of negative SHAP (priority counties)", fill = NULL)
ggsave(file.path(PLOT_DIR, "DRV_FamilyShare_byYear.tiff"),
       p_stack, width = 7.5, height = 4.8, dpi = 600, compression = "lzw")
ggsave(file.path(PLOT_DIR, "DRV_FamilyShare_byYear.png"),
       p_stack, width = 7.5, height = 4.8, dpi = 300)

# 图3：强度热图（不分家族；log1p 统一色标；每年先选 Top-M）
set_topM <- drivers_year_agg %>%
  group_by(grow_year) %>%
  slice_max(order_by = mass_total, n = TOPM_HEATMAP, with_ties = FALSE) %>%
  ungroup() %>% distinct(driver_key)

heat_tbl <- drivers_year_agg %>%
  semi_join(set_topM, by = "driver_key") %>%
  mutate(mass_pos = pmax(mass_total, 0),
         mass_log = log1p(mass_pos)) %>%
  select(grow_year, driver_key, mass_total, mass_log)

order_driver <- heat_tbl %>%
  group_by(driver_key) %>%
  summarise(mass_sum = sum(mass_total, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(mass_sum)) %>% pull(driver_key)

global_min <- min(heat_tbl$mass_log, na.rm = TRUE)
global_max <- max(heat_tbl$mass_log, na.rm = TRUE)

p_heat_intensity <- ggplot(
  heat_tbl %>% mutate(driver_key = factor(driver_key, levels = order_driver)),
  aes(x = factor(grow_year), y = driver_key, fill = mass_log)
) +
  geom_tile(color = "white", linewidth = 0.2) +
  scale_fill_viridis_c(
    option = "D", begin = 0.05, end = 0.95, name = "Intensity (log1p)",
    limits = c(global_min, global_max), oob = scales::squish, na.value = "grey95"
  ) +
  labs(x = "Year", y = "Driver (TopM per year)") +
  theme_classic(base_size = 11) +
  theme(axis.ticks = element_line(linewidth = 0.3),
        axis.line  = element_line(linewidth = 0.5),
        panel.grid = element_blank(),
        legend.position = "right")

heat_h <- max(4.8, 0.28 * length(unique(order_driver)))
ggsave(file.path(PLOT_DIR, "DRV_TopM_Heatmap_INTENSITY_ONLY.tiff"),
       p_heat_intensity, width = 8.6, height = heat_h, dpi = 600, compression = "lzw")
ggsave(file.path(PLOT_DIR, "DRV_TopM_Heatmap_INTENSITY_ONLY.png"),
       p_heat_intensity, width = 8.6, height = heat_h, dpi = 300)

cat("✔ 已导出：\n - ",
    normalizePath(file.path(DRV_DIR, "priority_counties_top_drivers.csv")), "\n - ",
    normalizePath(file.path(DRV_DIR, "year_aggregated_drivers.csv")), "\n - ",
    normalizePath(file.path(DRV_DIR, "priority_drivers_outputs.xlsx")), "\n - ",
    normalizePath(PLOT_DIR), "\n", sep="")
